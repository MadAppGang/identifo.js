{"version":3,"file":"identifo.js","sources":["../src/api/model.ts","../src/api/api.ts","../src/constants.ts","../src/iframe.ts","../src/store-manager/cookie-storage.ts","../src/store-manager/storage-manager.ts","../src/store-manager/local-storage.ts","../src/store-manager/session-storage.ts","../src/tokenService.ts","../src/UrlBuilder.ts","../src/IdentifoAuth.ts"],"sourcesContent":["/* eslint-disable camelcase */\nexport enum APIErrorCodes {\n  PleaseEnableTFA = 'error.api.request.2fa.please_enable',\n}\n\nexport enum TFAType {\n  TFATypeApp = 'app',\n  TFATypeSMS = 'sms',\n  TFATypeEmail = 'email',\n}\nexport interface ApiRequestError {\n  error: {\n    detailed_message?: string;\n    id?: APIErrorCodes;\n    message?: string;\n    status?: number;\n  };\n}\nexport class ApiError extends Error {\n  detailedMessage?: string;\n\n  id?: APIErrorCodes;\n\n  status?: number;\n\n  constructor(error?: ApiRequestError['error']) {\n    super(error?.message || 'Unknown API error');\n    this.detailedMessage = error?.detailed_message;\n    this.id = error?.id;\n    this.status = error?.status;\n  }\n}\nexport interface LoginResponse {\n  access_token?: string;\n  refresh_token?: string;\n  require_2fa: boolean;\n  enabled_2fa: boolean;\n  user: {\n    active: boolean;\n    email: string;\n    id: string;\n    latest_login_time: number;\n    num_of_logins: number;\n    username: string;\n    tfa_info: { hotp_expired_at: string };\n  };\n}\nexport interface EnableTFAResponse {\n  provisioning_uri?: string;\n  provisioning_qr?: string;\n  access_token?: string;\n}\nexport interface AppSettingsResponse {\n  anonymousResitrationAllowed: boolean;\n  active: boolean;\n  description: string;\n  id: string;\n  newUserDefaultRole: string;\n  offline: boolean;\n  registrationForbidden: boolean;\n  tfaType: TFAType;\n}\n\nexport interface User {\n  id: string;\n  username: string;\n  email: string;\n  phone: string;\n  active: boolean;\n  tfa_info: {\n    is_enabled: boolean;\n  };\n  num_of_logins: number;\n  latest_login_time: number;\n  access_role: string;\n  anonymous: boolean;\n  federated_ids: string[];\n}\nexport interface UpdateUser {\n  new_email?: string;\n  new_phone?: string;\n}\nexport interface SuccessResponse {\n  result: 'ok';\n}\n","import axios, { AxiosError, AxiosInstance } from 'axios';\nimport TokenService from '../tokenService';\nimport { IdentifoConfig } from '../types/types';\nimport {\n  AppSettingsResponse,\n  EnableTFAResponse,\n  LoginResponse,\n  SuccessResponse,\n  UpdateUser,\n  User,\n  ApiRequestError,\n  ApiError,\n} from './model';\n\nconst APP_ID_HEADER_KEY = 'X-Identifo-Clientid';\nconst AUTHORIZATION_HEADER_KEY = 'Authorization';\n\nexport class Api {\n  authInstance: AxiosInstance = axios.create();\n\n  catchHandler = (e: AxiosError<ApiRequestError>): never => {\n    throw new ApiError(e.response?.data.error);\n  };\n\n  constructor(private config: IdentifoConfig, private tokenService: TokenService) {\n    this.authInstance = axios.create({\n      baseURL: `${config.url}`,\n      headers: {\n        [APP_ID_HEADER_KEY]: config.appId,\n      },\n    });\n  }\n\n  async getUser(): Promise<User> {\n    if (!this.tokenService.getToken()?.token) {\n      throw new Error('No token in token service.');\n    }\n    return this.authInstance\n      .get<User>('/me', {\n        headers: {\n          [AUTHORIZATION_HEADER_KEY]: `Bearer ${this.tokenService.getToken()?.token}`,\n        },\n      })\n      .then((r) => r.data)\n      .catch(this.catchHandler);\n  }\n\n  async renewToken(): Promise<LoginResponse> {\n    if (!this.tokenService.getToken('refresh')?.token) {\n      throw new Error('No token in token service.');\n    }\n    return this.authInstance\n      .get<LoginResponse>('/auth/renew', {\n        headers: {\n          [AUTHORIZATION_HEADER_KEY]: `Bearer ${this.tokenService.getToken('refresh')?.token}`,\n        },\n      })\n      .then((r) => r.data)\n      .then((r) => this.storeToken(r))\n      .catch(this.catchHandler);\n  }\n\n  async updateUser(user: UpdateUser): Promise<User> {\n    if (!this.tokenService.getToken()?.token) {\n      throw new Error('No token in token service.');\n    }\n    return this.authInstance\n      .put<User>('/me', user, {\n        headers: {\n          [AUTHORIZATION_HEADER_KEY]: `Bearer ${this.tokenService.getToken('refresh')?.token}`,\n        },\n      })\n      .then((r) => r.data)\n      .catch(this.catchHandler);\n  }\n\n  async login(username: string, password: string, deviceToken: string, scopes: string[]): Promise<LoginResponse> {\n    const data = {\n      username,\n      password,\n      device_token: deviceToken,\n      scopes,\n    };\n\n    return this.authInstance\n      .post<LoginResponse>('/auth/login', data)\n      .then((r) => r.data)\n      .then((r) => this.storeToken(r))\n      .catch(this.catchHandler);\n  }\n\n  async register(username: string, password: string, email: string, phone: string): Promise<LoginResponse> {\n    const data = {\n      username,\n      password,\n      email,\n      phone,\n    };\n\n    return this.authInstance\n      .post<LoginResponse>('/auth/register', data)\n      .then((r) => r.data)\n      .then((r) => this.storeToken(r))\n      .catch(this.catchHandler);\n  }\n\n  async requestResetPassword(email: string): Promise<SuccessResponse> {\n    const data = {\n      email,\n    };\n\n    return this.authInstance\n      .post<SuccessResponse>('/auth/request_reset_password', data)\n      .then((r) => r.data)\n      .catch(this.catchHandler);\n  }\n\n  async resetPassword(password: string): Promise<SuccessResponse> {\n    if (!this.tokenService.getToken()?.token) {\n      throw new Error('No token in token service.');\n    }\n    const data = {\n      password,\n    };\n\n    return this.authInstance\n      .post<SuccessResponse>('/auth/reset_password', data, {\n        headers: {\n          [AUTHORIZATION_HEADER_KEY]: `Bearer ${this.tokenService.getToken()?.token}`,\n        },\n      })\n      .then((r) => r.data)\n      .catch(this.catchHandler);\n  }\n\n  async getAppSettings(): Promise<AppSettingsResponse> {\n    return this.authInstance\n      .get<AppSettingsResponse>('/auth/app_settings')\n      .then((r) => r.data)\n      .catch(this.catchHandler);\n  }\n\n  async enableTFA(): Promise<EnableTFAResponse> {\n    if (!this.tokenService.getToken()?.token) {\n      throw new Error('No token in token service.');\n    }\n    return this.authInstance\n      .put<EnableTFAResponse>(\n        '/auth/tfa/enable',\n        {},\n        { headers: { [AUTHORIZATION_HEADER_KEY]: `BEARER ${this.tokenService.getToken()?.token}` } },\n      )\n      .then((r) => r.data)\n      .catch(this.catchHandler);\n  }\n\n  async verifyTFA(code: string, scopes: string[]): Promise<LoginResponse> {\n    if (!this.tokenService.getToken()?.token) {\n      throw new Error('No token in token service.');\n    }\n    return this.authInstance\n      .post<LoginResponse>(\n        '/auth/tfa/login',\n        { tfa_code: code, scopes },\n        { headers: { [AUTHORIZATION_HEADER_KEY]: `BEARER ${this.tokenService.getToken()?.token}` } },\n      )\n      .then((r) => r.data)\n      .then((r) => this.storeToken(r))\n      .catch(this.catchHandler);\n  }\n\n  storeToken(response: LoginResponse): LoginResponse {\n    if (response.access_token) {\n      this.tokenService.saveToken(response.access_token, 'access');\n    }\n    if (response.refresh_token) {\n      this.tokenService.saveToken(response.refresh_token, 'refresh');\n    }\n    return response;\n  }\n}\n","export const jwtRegex = /^([a-zA-Z0-9_=]+)\\.([a-zA-Z0-9_=]+)\\.([a-zA-Z0-9_\\-=]*$)/;\n\n// Error messages\n\nexport const INVALID_TOKEN_ERROR = 'Empty or invalid token';\n\n// url query params keys\nexport const TOKEN_QUERY_KEY = 'token';\nexport const REFRESH_TOKEN_QUERY_KEY = 'refresh_token';\n","const Iframe = {\n  create(): HTMLIFrameElement {\n    const iframe = document.createElement('iframe');\n    iframe.style.display = 'none';\n    document.body.appendChild(iframe);\n    return iframe;\n  },\n\n  remove(iframe: HTMLIFrameElement): void {\n    setTimeout(() => {\n      if (document.body.contains(iframe)) {\n        document.body.removeChild(iframe);\n      }\n    }, 0);\n  },\n\n  captureMessage(iframe: HTMLIFrameElement, src: string): Promise<string> {\n    return new Promise((resolve, reject) => {\n      const handleMessage = (event: MessageEvent<{ error: string; accessToken: string }>) => {\n        if (event.data.error) reject(event.data.error);\n\n        resolve(event.data.accessToken);\n\n        window.removeEventListener('message', handleMessage);\n      };\n\n      window.addEventListener('message', handleMessage, false);\n      // eslint-disable-next-line no-param-reassign\n      iframe.src = src;\n    });\n  },\n};\n\nexport default Iframe;\n","class CookieStorage {\n  isAccessible = false;\n\n  saveToken(): boolean {\n    return true;\n  }\n\n  getToken(): string {\n    throw new Error('Can not get token from HttpOnly');\n  }\n\n  deleteToken(): void {\n    // throw new Error('Can not get token from HttpOnly');\n  }\n}\n\nexport default CookieStorage;\n","import { TokenManager, TokenType } from '../types/types';\n\nclass StorageManager implements TokenManager {\n  preffix = 'identifo_';\n\n  storageType: 'localStorage' | 'sessionStorage' = 'localStorage';\n\n  access = `${this.preffix}access_token`;\n\n  refresh = `${this.preffix}refresh_token`;\n\n  isAccessible = true;\n\n  constructor(storageType: 'localStorage' | 'sessionStorage', accessKey?: string, refreshKey?: string) {\n    this.access = accessKey ? this.preffix + accessKey : this.access;\n    this.refresh = refreshKey ? this.preffix + refreshKey : this.refresh;\n    this.storageType = storageType;\n  }\n\n  saveToken(token: string, tokenType: TokenType): boolean {\n    if (token) {\n      window[this.storageType].setItem(this[tokenType], token);\n      return true;\n    }\n    return false;\n  }\n\n  getToken(tokenType: TokenType): string {\n    return window[this.storageType].getItem(this[tokenType]) ?? '';\n  }\n\n  deleteToken(tokenType: TokenType): void {\n    window[this.storageType].removeItem(this[tokenType]);\n  }\n}\n\nexport default StorageManager;\n","import StorageManager from './storage-manager';\n\nclass LocalStorage extends StorageManager {\n  constructor(accessKey?: string, refreshKey?: string) {\n    super('localStorage', accessKey, refreshKey);\n  }\n}\n\nexport default LocalStorage;\n","import StorageManager from './storage-manager';\n\nclass SessionStorage extends StorageManager {\n  constructor(accessKey?: string, refreshKey?: string) {\n    super('sessionStorage', accessKey, refreshKey);\n  }\n}\n\nexport default SessionStorage;\n","import { INVALID_TOKEN_ERROR } from './constants';\nimport { LocalStorageManager } from './store-manager';\nimport { ClientToken, JWTPayload, TokenManager, TokenType } from './types/types';\n\nclass TokenService {\n  private tokenManager: TokenManager;\n\n  constructor(tokenManager?: TokenManager) {\n    this.tokenManager = tokenManager || new LocalStorageManager();\n    // TODO: implement cookie as default\n    // this.tokenManager = tokenManager || new CoockieStorage();\n  }\n\n  async handleVerification(token: string, audience: string, issuer?: string): Promise<boolean> {\n    if (!this.tokenManager.isAccessible) return true;\n    try {\n      await this.validateToken(token, audience, issuer);\n      this.saveToken(token);\n      return true;\n    } catch (err) {\n      this.removeToken();\n      return Promise.reject(err);\n    }\n  }\n\n  async validateToken(token: string, audience: string, issuer?: string): Promise<boolean> {\n    if (!token) throw new Error(INVALID_TOKEN_ERROR);\n    const jwtPayload = this.parseJWT(token);\n    const isJwtExpired = this.isJWTExpired(jwtPayload);\n    if (jwtPayload.aud?.includes(audience) && (!issuer || jwtPayload.iss === issuer) && !isJwtExpired) {\n      return Promise.resolve(true);\n    }\n    throw new Error(INVALID_TOKEN_ERROR);\n  }\n\n  parseJWT(token: string): JWTPayload {\n    const base64Url = token.split('.')[1];\n    if (!base64Url) return { aud: [], iss: '', exp: 10 };\n    const base64 = base64Url.replace(/-/g, '+').replace(/_/g, '/');\n    const jsonPayload = decodeURIComponent(\n      atob(base64)\n        .split('')\n        .map((c) => `%${`00${c.charCodeAt(0).toString(16)}`.slice(-2)}`)\n        .join(''),\n    );\n    return JSON.parse(jsonPayload) as JWTPayload;\n  }\n\n  isJWTExpired(token: JWTPayload): boolean {\n    const now = new Date().getTime() / 1000;\n    if (token.exp && now > token.exp) {\n      return true;\n    }\n    return false;\n  }\n\n  isAuthenticated(audience: string, issuer?: string): Promise<boolean> {\n    if (!this.tokenManager.isAccessible) return Promise.resolve(true);\n    const token = this.tokenManager.getToken('access');\n    // TODO: may be change to handleAuth instead validateToken\n    return this.validateToken(token, audience, issuer);\n  }\n\n  saveToken(token: string, type: TokenType = 'access'): boolean {\n    return this.tokenManager.saveToken(token, type);\n  }\n\n  removeToken(type: TokenType = 'access'): void {\n    this.tokenManager.deleteToken(type);\n  }\n\n  getToken(type: TokenType = 'access'): ClientToken | null {\n    const token = this.tokenManager.getToken(type);\n    if (!token) return null;\n    const jwtPayload = this.parseJWT(token);\n    return { token, payload: jwtPayload };\n  }\n}\n\nexport default TokenService;\n","import { IdentifoConfig, UrlFlows } from './types/types';\n\nexport class UrlBuilder {\n  constructor(private config: IdentifoConfig) {}\n\n  getUrl(flow: UrlFlows): string {\n    const scopes = JSON.stringify(this.config.scopes ?? []);\n    const redirectUri = encodeURIComponent(this.config.redirectUri ?? window.location.href);\n    const baseParams = `appId=${this.config.appId}&scopes=${scopes}`;\n    const urlParams = `${baseParams}&callbackUrl=${redirectUri}`;\n    // if postLogoutRedirectUri is empty, login url will be instead\n    const postLogoutRedirectUri = this.config.postLogoutRedirectUri\n      ? `&callbackUrl=${encodeURIComponent(this.config.postLogoutRedirectUri)}`\n      : `&callbackUrl=${redirectUri}&redirectUri=${this.config.url}/web/login?${encodeURIComponent(baseParams)}`;\n\n    const urls = {\n      signup: `${this.config.url}/web/register?${urlParams}`,\n      signin: `${this.config.url}/web/login?${urlParams}`,\n      logout: `${this.config.url}/web/logout?${baseParams}${postLogoutRedirectUri}`,\n      renew: `${this.config.url}/web/token/renew?${baseParams}&redirectUri=${redirectUri}`,\n      default: 'default',\n    };\n\n    return urls[flow] || urls.default;\n  }\n\n  createSignupUrl(): string {\n    return this.getUrl('signup');\n  }\n\n  createSigninUrl(): string {\n    return this.getUrl('signin');\n  }\n\n  createLogoutUrl(): string {\n    return this.getUrl('logout');\n  }\n\n  createRenewSessionUrl(): string {\n    return this.getUrl('renew');\n  }\n}\n","import { Api } from './api/api';\nimport { jwtRegex, REFRESH_TOKEN_QUERY_KEY, TOKEN_QUERY_KEY } from './constants';\nimport Iframe from './iframe';\nimport TokenService from './tokenService';\nimport { ClientToken, IdentifoConfig, UrlBuilderInit } from './types/types';\nimport { UrlBuilder } from './UrlBuilder';\n\nclass IdentifoAuth {\n  public api: Api;\n\n  public config: IdentifoConfig;\n\n  private urlBuilder: UrlBuilderInit;\n\n  private tokenService: TokenService;\n\n  private token: ClientToken | null = null;\n\n  private refreshToken: string | null = null;\n\n  private renewSessionId: number | undefined;\n\n  isAuth = false;\n\n  constructor(config: IdentifoConfig) {\n    this.config = { ...config, autoRenew: config.autoRenew ?? true };\n    this.tokenService = new TokenService(config.tokenManager);\n    this.urlBuilder = new UrlBuilder(this.config);\n    this.api = new Api(config, this.tokenService);\n  }\n\n  init(): void {\n    const token = this.tokenService.getToken();\n    if (token) {\n      const isExpired = this.tokenService.isJWTExpired(token.payload);\n      if (isExpired) {\n        this.renewSession()\n          .then((t) => this.handleToken(t))\n          .catch(() => this.resetAuthValues());\n      } else {\n        this.handleToken(token.token);\n      }\n    }\n  }\n\n  private handleToken(token: string) {\n    const payload = this.tokenService.parseJWT(token);\n    this.token = { token, payload };\n    this.isAuth = true;\n    this.tokenService.saveToken(token);\n    if (this.renewSessionId) {\n      window.clearTimeout(this.renewSessionId);\n    }\n    if (payload.exp) {\n      this.renewSessionId = window.setTimeout(() => {\n        if (this.config.autoRenew) {\n          this.renewSession()\n            .then((t) => this.handleToken(t))\n            .catch(() => this.resetAuthValues());\n        } else {\n          this.resetAuthValues();\n        }\n      }, (payload.exp - new Date().getTime() / 1000 - 60000) * 1000);\n    }\n  }\n\n  private resetAuthValues() {\n    this.token = null;\n    this.isAuth = false;\n    this.tokenService.removeToken();\n  }\n\n  signup(): void {\n    window.location.href = this.urlBuilder.createSignupUrl();\n  }\n\n  signin(): void {\n    window.location.href = this.urlBuilder.createSigninUrl();\n  }\n\n  logout(): void {\n    this.tokenService.removeToken('access');\n    window.location.href = this.urlBuilder.createLogoutUrl();\n  }\n\n  async handleAuthentication(): Promise<boolean> {\n    const { access } = this.getTokenFromUrl();\n    if (!access) {\n      return Promise.reject();\n    }\n    try {\n      await this.tokenService.handleVerification(access, this.config.appId, this.config.issuer);\n      this.handleToken(access);\n      return await Promise.resolve(true);\n    } catch (err) {\n      return await Promise.reject();\n    } finally {\n      // TODO: Nikita K cahnge correct window key\n      window.location.hash = '';\n    }\n  }\n\n  private getTokenFromUrl(): { access: string; refresh: string } {\n    const urlParams = new URLSearchParams(window.location.search);\n    const tokens = { access: '', refresh: '' };\n    const accessToken = urlParams.get(TOKEN_QUERY_KEY);\n    const refreshToken = urlParams.get(REFRESH_TOKEN_QUERY_KEY);\n\n    if (refreshToken && jwtRegex.test(refreshToken)) {\n      tokens.refresh = refreshToken;\n    }\n    if (accessToken && jwtRegex.test(accessToken)) {\n      tokens.access = accessToken;\n    }\n\n    return tokens;\n  }\n\n  getToken(): ClientToken {\n    if (this.token) {\n      return this.token;\n    }\n\n    return { token: '', payload: {} };\n  }\n\n  async renewSession(): Promise<string> {\n    try {\n      const token = await this.renewSessionWithIframe();\n      this.handleToken(token);\n      return await Promise.resolve(token);\n    } catch (err) {\n      return Promise.reject();\n    }\n  }\n\n  private async renewSessionWithToken(): Promise<string> {\n    try {\n      const r = await this.api.renewToken().then((l) => l.access_token || '');\n      return r;\n    } catch (err) {\n      return Promise.resolve('');\n    }\n  }\n\n  private async renewSessionWithIframe(): Promise<string> {\n    const iframe = Iframe.create();\n    const timeout = setTimeout(() => {\n      Iframe.remove(iframe);\n      throw new Error('Timeout expired');\n    }, 30000);\n    try {\n      const token = await Iframe.captureMessage(iframe, this.urlBuilder.createRenewSessionUrl());\n      await this.tokenService.handleVerification(token, this.config.appId, this.config.issuer);\n      return token;\n    } catch (err) {\n      return Promise.reject(err);\n    } finally {\n      clearTimeout(timeout);\n      Iframe.remove(iframe);\n    }\n  }\n}\nexport default IdentifoAuth;\n"],"names":["APIErrorCodes","TFAType","axios","LocalStorageManager"],"mappings":"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"}